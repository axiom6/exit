// Generated by CoffeeScript 1.9.1
(function() {
  var Stream;

  Stream = (function() {
    Util.Export(Stream, 'app/Stream');

    function Stream(app) {
      this.app = app;
      if ($().bindAsObservable == null) {
        Util.error('Stream rxjs-jquery not defined');
      }
      this.subjects = {};
      this.subjects['Select'] = new Rx.Subject();
      this.subjects['Orient'] = new Rx.Subject();
      this.subjects['Destination'] = new Rx.Subject();
    }

    Stream.prototype.getSubject = function(prop, warn) {
      if (warn == null) {
        warn = false;
      }
      if (this.subjects[prop] != null) {
        this.subjects[prop];
      } else {
        if (warn) {
          Util.warn('App.Pub.getSubject() unknown subject so returning new subject for', prop);
        }
        this.subjects[prop] = new Rx.Subject();
      }
      return this.subjects[prop];
    };

    Stream.prototype.publish = function(prop, jqSel, eventType, topic, from) {
      var object, onNext, subject;
      subject = this.getSubject(prop);
      object = {
        from: from,
        topic: topic
      };
      onNext = (function(_this) {
        return function(event) {
          _this.processEvent(event);
          if (eventType !== 'click') {
            object.value = event.target.value;
          }
          return subject.onNext(object);
        };
      })(this);
      this.subscribeEvent(onNext, jqSel, eventType, object);
      return subject;
    };

    Stream.prototype.subscribe = function(prop, onNext) {
      var subject, subscription;
      subject = this.getSubject(prop, false);
      subscription = subject.subscribe(onNext, this.onError, this.onComplete);
      return subscription;
    };

    Stream.prototype.push = function(prop, topic, from) {
      var object, onNext, subject;
      subject = this.getSubject(prop);
      object = {
        from: from,
        topic: topic
      };
      onNext = function() {
        return subject.onNext(object);
      };
      return subject.subscribe(onNext, this.onError, this.onComplete);
    };

    Stream.prototype.createRxJQuery = function(jqSel, object) {
      if (Util.isJQuery(jqSel)) {
        return jqSel;
      } else if (Util.isStr(jqSel)) {
        return $(jqSel);
      } else {
        Util.error('App.Pub.createRxJQuery( jqSel )', object, typeof jqSel, 'jqSel is neither jQuery object nor selector');
        return $();
      }
    };

    Stream.prototype.onError = function(error) {
      return Util.error('App.Pub.onError()', error);
    };

    Stream.prototype.onComplete = function() {
      return Util.log('App.Pub.onComplete()', 'Completed');
    };

    Stream.prototype.subscribeEvent = function(onNext, jqSel, eventType, object) {
      var observable, rxjq, subscription;
      rxjq = this.createRxJQuery(jqSel, object);
      observable = rxjq.bindAsObservable(eventType);
      subscription = observable.subscribe(onNext, this.onError, this.onComplete);
      return subscription;
    };

    Stream.prototype.processEvent = function(event) {
      if (event != null) {
        event.stopPropagation();
      }
      return event != null ? event.preventDefault() : void 0;
    };

    Stream.prototype.toggleNavbTocs = function(jqSel, from) {
      var onNext;
      onNext = (function(_this) {
        return function(event) {
          _this.processEvent(event);
          return _this.app.toggleNavbTocs();
        };
      })(this);
      return this.subscribeEvent(onNext, jqSel, 'click', 'toggleNavbTocs', from);
    };

    Stream.prototype.drag = function(jqSel) {
      var dragTarget, mousedown, mousedrag, mousemove, mouseup, subscription;
      dragTarget = this.createRxJQuery(jqSel);
      mouseup = dragTarget.bindAsObservable("mouseup").publish().refCount();
      mousemove = $(document).bindAsObservable("mousemove").publish().refCount();
      mousedown = dragTarget.bindAsObservable("mousedown").publish().refCount().map(function(event) {
        event.preventDefault();
        return {
          left: event.clientX - dragTarget.offset().left,
          top: event.clientY - dragTarget.offset().top
        };
      });
      mousedrag = mousedown.selectMany(function(offset) {
        return mousemove.map(function(pos) {
          return {
            left: pos.clientX - offset.left,
            top: pos.clientY - offset.top
          };
        }).takeUntil(mouseup);
      });
      return subscription = mousedrag.subscribe(function(pos) {
        dragTarget.css({
          top: pos.top,
          left: pos.left
        });
      });
    };

    return Stream;

  })();

}).call(this);
